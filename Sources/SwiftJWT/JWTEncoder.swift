/**
 * Copyright IBM Corporation 2018
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

import Foundation
import KituraContracts

// MARK: JWTEncoder

/**
 A thread safe encoder that signs the JWT header and claims using the provided algorithm and encodes a `JWT` instance as either Data or a JWT String.

 ### Usage Example: ###
 ```swift
 struct MyClaims: Claims {
    var name: String
 }
 var jwt = JWT(claims: MyClaims(name: "John Doe"))
 let privateKey = "<PrivateKey>".data(using: .utf8)!
 let rsaJWTEncoder = JWTEncoder(jwtSigner: JWTSigner.rs256(privateKey: privateKey))
 do {
    let jwtString = try rsaJWTEncoder.encodeToString(jwt)
 } catch {
    print("Failed to encode JWT: \(error)")
 }
 ```
 */
public class JWTEncoder: BodyEncoder {
	let keyIDToSigner: (String) -> JWTSigner?
	let jwtSigner: JWTSigner?

	// MARK: Initializers

	/// Initialize a `JWTEncoder` instance with a single `JWTSigner`.
	///
	/// - Parameter jwtSigner: The `JWTSigner` that will be used to sign the JWT.
	/// - Returns: A new instance of `JWTEncoder`.
	public init(jwtSigner: JWTSigner) {
		keyIDToSigner = { _ in jwtSigner }
		self.jwtSigner = jwtSigner
	}

	/// Initialize a `JWTEncoder` instance with a function to generate the `JWTSigner` from the JWT `kid` header.
	///
	/// - Parameter keyIDToSigner: The function to generate the `JWTSigner` from the JWT `kid` header.
	/// - Returns: A new instance of `JWTEncoder`.
	public init(keyIDToSigner: @escaping (String) -> JWTSigner?) {
		self.keyIDToSigner = keyIDToSigner
		jwtSigner = nil
	}

	// MARK: Encode

	/// Encode a `JWT` instance into a UTF8 encoded JWT String.
	///
	/// - Parameter value: The JWT instance to be encoded as Data.
	/// - Returns: The UTF8 encoded JWT String.
	/// - throws: `JWTError.invalidUTF8Data` if the provided Data can't be decoded to a String.
	/// - throws: `JWTError.invalidKeyID` if the KeyID `kid` header fails to generate a jwtSigner.
	/// - throws: `EncodingError` if the encoder fails to encode the object as Data.
	public func encode(_ value: some Encodable) throws -> Data {
		guard let jwt = try encodeToString(value).data(using: .utf8) else {
			throw JWTError.invalidUTF8Data
		}
		return jwt
	}

	/// Encode a `JWT` instance as a JWT String.
	///
	/// - Parameter value: The JWT instance to be encoded as a JWT String.
	/// - Returns: A JWT String.
	/// - throws: `JWTError.invalidKeyID` if the KeyID `kid` header fails to generate a jwtSigner.
	/// - throws: `EncodingError` if the encoder fails to encode the object as Data.
	public func encodeToString(_ value: some Encodable) throws -> String {
		let encoder = _JWTEncoder(jwtSigner: jwtSigner, keyIDToSigner: keyIDToSigner)
		try value.encode(to: encoder)
		guard let header = encoder.header,
		      let claims = encoder.claims,
		      let jwtSigner = encoder.jwtSigner
		else {
			throw EncodingError.invalidValue(value, EncodingError.Context(codingPath: [], debugDescription: "Failed to sign JWT Header and Claims"))
		}
		return try jwtSigner.sign(header: header, claims: claims)
	}
}

/*
 The JWTEncoder creates it's own instance of _JWTEncoder everytime the encode function is called.
 This is because the _JWTEncoder changes it's own value so we can only have one thread using it at a time.
 The following is the code generated by codable and called by JWTEncoder.encode() -> String for a JWT<MyClaims> struct:
 ```
 enum MyStructKeys: String, CodingKey {
    case header, claims
 }
 extension JWT<MyClaims>: Encodable {
     func encode(to encoder: Encoder) throws {
         var container = encoder.container(keyedBy: CodingKeys.self)
         try container.encode(header, forKey: .header)
         try container.encode(claims, forKey: .claims)
     }
 }
 ```
 Where encoder is a _JWTEncoder instance, and MyClaims is the user defined object conforming to Claims.
 */
private class _JWTEncoder: Encoder {
	init(jwtSigner: JWTSigner?, keyIDToSigner: @escaping (String) -> JWTSigner?) {
		self.jwtSigner = jwtSigner
		self.keyIDToSigner = keyIDToSigner
	}

	var claims: String?

	var header: String?

	var jwtSigner: JWTSigner?

	let keyIDToSigner: (String) -> JWTSigner?

	var codingPath: [CodingKey] = []

	var userInfo: [CodingUserInfoKey: Any] = [:]

	// We will be provided a keyed container representing the JWT instance
	func container<Key: CodingKey>(keyedBy _: Key.Type) -> KeyedEncodingContainer<Key> {
		let container = _JWTKeyedEncodingContainer<Key>(encoder: self, codingPath: codingPath)
		return KeyedEncodingContainer(container)
	}

	private struct _JWTKeyedEncodingContainer<Key: CodingKey>: KeyedEncodingContainerProtocol {
		/// A reference to the encoder we're writing to.
		let encoder: _JWTEncoder

		var codingPath: [CodingKey]

		// Set the Encoder header and claims Strings using the container
		mutating func encode(_ value: some Encodable, forKey key: Key) throws {
			codingPath.append(key)
			let fieldName = key.stringValue
			let jsonEncoder = JSONEncoder()
			jsonEncoder.dateEncodingStrategy = .secondsSince1970
			if fieldName == "header" {
				guard var _header = value as? Header else {
					throw EncodingError.invalidValue(value, EncodingError.Context(codingPath: [], debugDescription: "Failed to encode into header CodingKey"))
				}
				// Set the jwtSigner while you have acces to the keyID
				if encoder.jwtSigner == nil {
					guard let keyID = _header.kid, let keyIDJWTSigner = encoder.keyIDToSigner(keyID) else {
						throw JWTError.invalidKeyID
					}
					encoder.jwtSigner = keyIDJWTSigner
				}
				_header.alg = encoder.jwtSigner?.name
				let data = try jsonEncoder.encode(_header)
				encoder.header = JWTEncoder.base64urlEncodedString(data: data)
			} else if fieldName == "claims" {
				let data = try jsonEncoder.encode(value)
				encoder.claims = JWTEncoder.base64urlEncodedString(data: data)
			}
		}

		// No functions beyond this point should be called for encoding a JWT token
		mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey _: Key) -> KeyedEncodingContainer<NestedKey> where NestedKey: CodingKey {
			encoder.container(keyedBy: keyType)
		}

		mutating func nestedUnkeyedContainer(forKey _: Key) -> UnkeyedEncodingContainer {
			encoder.unkeyedContainer()
		}

		mutating func superEncoder() -> Encoder {
			encoder
		}

		mutating func superEncoder(forKey _: Key) -> Encoder {
			encoder
		}

		// Throw if trying to encode something other than a JWT token
		mutating func encodeNil(forKey key: Key) throws {
			throw EncodingError.invalidValue(key, EncodingError.Context(codingPath: codingPath, debugDescription: "JWTEncoder can only encode JWT tokens"))
		}
	}

	func unkeyedContainer() -> UnkeyedEncodingContainer {
		UnkeyedContainer(encoder: self)
	}

	func singleValueContainer() -> SingleValueEncodingContainer {
		UnkeyedContainer(encoder: self)
	}

	// This Decoder should not be used to decode UnkeyedContainer
	private struct UnkeyedContainer: UnkeyedEncodingContainer, SingleValueEncodingContainer {
		var encoder: _JWTEncoder

		var codingPath: [CodingKey] { [] }

		var count: Int { 0 }

		func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> where NestedKey: CodingKey {
			encoder.container(keyedBy: keyType)
		}

		func nestedUnkeyedContainer() -> UnkeyedEncodingContainer {
			self
		}

		func superEncoder() -> Encoder {
			encoder
		}

		func encodeNil() throws {}

		func encode(_ value: some Encodable) throws {
			throw EncodingError.invalidValue(value, EncodingError.Context(codingPath: codingPath, debugDescription: "JWTEncoder can only encode JWT tokens"))
		}
	}
}
